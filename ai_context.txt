Notes: Rasp Pi at "ssh starfarm@192.168.1.216" -- try "ping 192.168.1.216" beforehand optionally.

The project is a wireless communciation project:

1. A TRANSMITTER is an Adafruit Feather M0 LoRa single board computer. It is connected via I2C to a SHT31-D temperature and humidity sensor. The design should be low power.

2. The TRANSMITTER is transmitting temperature and humidity measurements on some fixed interval

3. The RECEIVER is another Adafruit Feather M0 connected to a Raspberry Pi model B. The Pi and M0 are connected via microUSB <-> USB, and the M0 acts as the antenna + receiver. The Raspberry Pi is also connected via ethernet to a Starlink router, so it can transmit the received data to the internet.

Here's the RX .ino file from the arduino lib:

// Feather M0 LoRa (RFM95) — Minimal RX for JSON payloads w/ addressing
// Libs: RadioHead (RH_RF95)
// Matches TX that sends: {"net":165,"node":1,"seq":N,"ts":...,"vbat":X,"t":Y,"rh":Z}

#include <SPI.h>
#include <RH_RF95.h>

#define RFM95_CS   8
#define RFM95_RST  4
#define RFM95_INT  3
#define RF95_FREQ_MHZ 915.0

// --- Addressing: must match the transmitter code ---
#define MY_ADDR   0x42   // receiver's node ID (TX's DEST_ADDR)
#define TX_ADDR   0x01   // expected transmitter "from"
#define NET_ID    0xA5   // app-level net id inside JSON

RH_RF95 rf95(RFM95_CS, RFM95_INT);

void hardResetRadio() {
  pinMode(RFM95_RST, OUTPUT);
  digitalWrite(RFM95_RST, HIGH); delay(10);
  digitalWrite(RFM95_RST, LOW);  delay(10);
  digitalWrite(RFM95_RST, HIGH); delay(10);
}

// Tiny/brittle JSON helpers: pull int/float after a key like "seq" or "t"
static long jgetInt(const char* j, const char* key, long def=-1) {
  char pat[12]; snprintf(pat, sizeof(pat), "\"%s\":", key);
  const char* p = strstr(j, pat); if (!p) return def;
  return strtol(p + strlen(pat), nullptr, 10);
}
static double jgetFloat(const char* j, const char* key, double def=NAN) {
  char pat[12]; snprintf(pat, sizeof(pat), "\"%s\":", key);
  const char* p = strstr(j, pat); if (!p) return def;
  return strtod(p + strlen(pat), nullptr);
}

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  Serial.begin(115200);
  while (!Serial && millis() < 3000) {}

  hardResetRadio();
  if (!rf95.init()) {
    while (1) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); delay(100); }
  }

  rf95.setFrequency(RF95_FREQ_MHZ);
  rf95.setThisAddress(MY_ADDR);       // accept only packets "to" me (or broadcast)
  // rf95.setModemConfig(RH_RF95::Bw125Cr45Sf128); // keep in sync w/ TX if you change it
  rf95.setModeRx();

  Serial.print("RX ready @ "); Serial.print(RF95_FREQ_MHZ);
  Serial.print(" MHz  addr=0x"); Serial.println(MY_ADDR, HEX);
}

void loop() {
  if (!rf95.available()) { delay(1); return; }

  uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];
  uint8_t len = sizeof(buf);
  if (!rf95.recv(buf, &len)) return;

  if (len >= sizeof(buf)) len = sizeof(buf) - 1;
  buf[len] = 0;                        // treat as C-string for parsing
  const char* json = (const char*)buf;

  // RadioHead headers (already filtered by "to==MY_ADDR" unless broadcast)
  uint8_t from = rf95.headerFrom();
  uint8_t to   = rf95.headerTo();
  uint8_t id   = rf95.headerId();
  int16_t rssi = rf95.lastRssi();

  // Optional extra guards (cheap, easy to debug)
  if (from != TX_ADDR) {               // not our expected TX; ignore quietly
    rf95.setModeRx(); return;
  }
  long net = jgetInt(json, "net", -1);
  if (net != NET_ID) { rf95.setModeRx(); return; }

  // Pull a few fields (brittle but readable); others remain in JSON
  long   seq   = jgetInt(json, "seq", -1);
  double vbat  = jgetFloat(json, "vbat", NAN);
  double tC    = jgetFloat(json, "t", NAN);
  double rhPct = jgetFloat(json, "rh", NAN);

  // One-line log: seq, RSSI, vbat, t, rh, and raw JSON for eyeballing
  Serial.print("ok seq="); Serial.print(seq);
  Serial.print(" from=0x"); Serial.print(from, HEX);
  Serial.print(" rssi=");   Serial.print(rssi);
  Serial.print(" vbat=");   Serial.print(vbat, 3);
  Serial.print(" tC=");     Serial.print(isnan(tC) ? NAN : tC, 2);
  Serial.print(" rh=");     Serial.print(isnan(rhPct) ? NAN : rhPct, 2);
  Serial.print(" id=");     Serial.print(id);          // headerId mirrors low byte of TX seq
  Serial.print(" | ");      Serial.println(json);      // full payload for debug

  // Quick LED blip = packet activity
  digitalWrite(LED_BUILTIN, HIGH); delay(15); digitalWrite(LED_BUILTIN, LOW);

  rf95.setModeRx(); // stay in RX after handling packet
}


Here's the TX .ino file:

// Feather M0 LoRa (RFM95 @ 915 MHz) — JSON TX with SHT31 + low power
// HW: Feather M0 LoRa (RFM95)  | Pins: CS=8, RST=4, INT=3  | VBAT on A7
// Libs: RadioHead (RH_RF95), Adafruit_SleepyDog, Adafruit_SHT31

#include <SPI.h>
#include <Wire.h>
#include <RH_RF95.h>
#include <Adafruit_SleepyDog.h>
#include <Adafruit_SHT31.h>

// ------------ RFM95 wiring (Feather M0 LoRa default) ------------
#define RFM95_CS   8
#define RFM95_RST  4
#define RFM95_INT  3

// ------------ Radio params ------------
#define RF95_FREQ_MHZ   915.0     // US ISM band
#define RF95_TX_DBM     10        // 5–13 for bring-up; lower saves power
#define SEND_INTERVAL_MS 15000UL  // extend for battery operation (e.g., 60_000+)

// ------------ Addressing (RadioHead headers) ------------
#define MY_ADDR    0x01           // this transmitter's node ID
#define DEST_ADDR  0x42           // receiver's node ID
#define NET_ID     0xA5           // app-level network ID (for debugging)

RH_RF95 rf95(RFM95_CS, RFM95_INT);
Adafruit_SHT31 sht31 = Adafruit_SHT31();

static uint32_t seq = 0;

// Feather M0 battery sense: A7 with 2:1 divider to 3.3V ADC ref
static float readVBAT() {
  analogReadResolution(12); // 0..4095 on SAMD21
  uint16_t raw = analogRead(A7);
  // Vbat = raw/4095 * 3.3V * 2 (divider)
  return (raw * (3.3f / 4095.0f) * 2.0f);
}

static void hardResetRadio() {
  pinMode(RFM95_RST, OUTPUT);
  digitalWrite(RFM95_RST, HIGH); delay(10);
  digitalWrite(RFM95_RST, LOW);  delay(10);
  digitalWrite(RFM95_RST, HIGH); delay(10);
}

static void sleepFor(uint32_t ms) {
  while (ms > 0) {
    int s = Watchdog.sleep(ms);
    if (s <= 0) break;
    ms -= s;
  }
}

void setup() {
  // Optional debug UART. Comment out in final deployment.
  Serial.begin(115200);
  while (!Serial && millis() < 3000) {}

  // I2C sensor
  Wire.begin();
  if (!sht31.begin(0x44)) { // most SHT31-D boards default to 0x44
    // Try the alternate address
    if (!sht31.begin(0x45)) {
      if (Serial) Serial.println("SHT31 not found");
    }
  }
  sht31.heater(false); // ensure heater is off

  // Radio init
  hardResetRadio();
  if (!rf95.init()) {
    pinMode(LED_BUILTIN, OUTPUT);
    if (Serial) Serial.println("RFM95 init failed");
    while (1) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); delay(100); }
  }

  rf95.setFrequency(RF95_FREQ_MHZ);
  rf95.setTxPower(RF95_TX_DBM, false); // false => PA_BOOST path on RFM95
  // Default modem: Bw125Cr45Sf128 (SF7). For long range (slower), consider:
  // rf95.setModemConfig(RH_RF95::Bw125Cr48Sf4096); // SF12

  // Addressing & filtering
  rf95.setThisAddress(MY_ADDR);
  rf95.setHeaderFrom(MY_ADDR);
  // Non-promiscuous by default: will *transmit* regardless; RX will filter.

  // Optional: LED pulse on boot
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); delay(40); digitalWrite(LED_BUILTIN, LOW);
}

void loop() {
  // --- Read sensors ---
  float tempC = NAN, rh = NAN;
  // Adafruit_SHT31 triggers single measurement internally; returns NAN on error
  tempC = sht31.readTemperature();
  rh    = sht31.readHumidity();

  // Battery
  const float vbat = readVBAT();

  // Timestamp
  const uint32_t ts = millis();

  // --- Build compact JSON payload ---
  // Example:
  // {"net":165,"node":1,"seq":123,"ts":456789,"vbat":4.12,"t":23.45,"rh":56.78}
  char json[160];
  int n = snprintf(
    json, sizeof(json),
    "{\"net\":%u,\"node\":%u,\"seq\":%lu,\"ts\":%lu,\"vbat\":%.3f,"
    "\"t\":%s,\"rh\":%s}",
    (unsigned)NET_ID,
    (unsigned)MY_ADDR,
    (unsigned long)seq,
    (unsigned long)ts,
    vbat,
    isnan(tempC) ? "null" : ([](float v){ static char b[16]; snprintf(b,sizeof(b),"%.2f",v); return b; })(tempC),
    isnan(rh)    ? "null" : ([](float v){ static char b[16]; snprintf(b,sizeof(b),"%.2f",v); return b; })(rh)
  );
  if (n < 0 || n >= (int)sizeof(json)) {
    // Fallback small packet if we ever overflow (shouldn't at this size)
    strcpy(json, "{\"err\":\"pkt_ovf\"}");
  }

  // --- Address headers (RadioHead) ---
  rf95.setHeaderTo(DEST_ADDR);
  rf95.setHeaderId((uint8_t)(seq & 0xFF));  // wraps every 256 packets
  rf95.setHeaderFlags(0x00);                // no special flags

  // --- Transmit ---
  rf95.send((uint8_t*)json, strlen(json));
  rf95.waitPacketSent();

  // Blink LED on each transmission
  digitalWrite(LED_BUILTIN, HIGH); delay(20); digitalWrite(LED_BUILTIN, LOW);

  if (Serial) {
    Serial.print("TX "); Serial.print(seq);
    Serial.print(" -> "); Serial.print(DEST_ADDR, HEX);
    Serial.print(" | "); Serial.println(json);
  }

  seq++;

  // --- Low power between sends ---
  rf95.sleep();                 // sleep the radio first
  sleepFor(SEND_INTERVAL_MS);   // deep sleep MCU (RTC)
}

And the RX's serial output:
ok seq=66 from=0x1 rssi=-113 vbat=4.344 tC=21.30 rh=61.79 id=66 | {"net":165,"node":1,"seq":66,"ts":18933,"vbat":4.344,"t":21.30,"rh":61.79}
ok seq=67 from=0x1 rssi=-112 vbat=4.337 tC=21.31 rh=61.78 id=67 | {"net":165,"node":1,"seq":67,"ts":19171,"vbat":4.337,"t":21.31,"rh":61.78}
ok seq=68 from=0x1 rssi=-114 vbat=4.342 tC=21.30 rh=61.87 id=68 | {"net":165,"node":1,"seq":68,"ts":19408,"vbat":4.342,"t":21.30,"rh":61.87}
ok seq=69 from=0x1 rssi=-115 vbat=4.345 tC=21.27 rh=61.95 id=69 | {"net":165,"node":1,"seq":69,"ts":19646,"vbat":4.345,"t":21.27,"rh":61.95}
ok seq=70 from=0x1 rssi=-124 vbat=4.342 tC=21.28 rh=61.91 id=70 | {"net":165,"node":1,"seq":70,"ts":19885,"vbat":4.342,"t":21.28,"rh":61.91}
ok seq=71 from=0x1 rssi=-112 vbat=4.342 tC=21.25 rh=61.92 id=71 | {"net":165,"node":1,"seq":71,"ts":20123,"vbat":4.342,"t":21.25,"rh":61.92}
ok seq=72 from=0x1 rssi=-113 vbat=4.345 tC=21.28 rh=61.92 id=72 | {"net":165,"node":1,"seq":72,"ts":20361,"vbat":4.345,"t":21.28,"rh":61.92}
ok seq=73 from=0x1 rssi=-113 vbat=4.342 tC=21.24 rh=61.91 id=73 | {"net":165,"node":1,"seq":73,"ts":20600,"vbat":4.342,"t":21.24,"rh":61.91}
ok seq=74 from=0x1 rssi=-111 vbat=4.337 tC=21.21 rh=62.03 id=74 | {"net":165,"node":1,"seq":74,"ts":20838,"vbat":4.337,"t":21.21,"rh":62.03}